// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "forge-std/console2.sol";
import "@dex/DexRouter.sol";

contract Commission2BTest is Test {
    address internal constant _ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint256 internal constant _ADDRESS_MASK =
        0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff;
    uint256 constant FROM_TOKEN_COMMISSION =
        0x3ca20afc2aaa0000000000000000000000000000000000000000000000000000;
    uint256 constant TO_TOKEN_COMMISSION =
        0x3ca20afc2bbb0000000000000000000000000000000000000000000000000000;
    uint256 constant FROM_TOKEN_COMMISSION_DUAL =
        0x22220afc2aaa0000000000000000000000000000000000000000000000000000;
    uint256 constant TO_TOKEN_COMMISSION_DUAL =
        0x22220afc2bbb0000000000000000000000000000000000000000000000000000;
    uint256 constant _TO_B_COMMISSION_MASK =
        0x8000000000000000000000000000000000000000000000000000000000000000;

    address user = 0x54b6032105A6DBdcdb21aD4A2707A8909AF153D7;
    address dexRouter = 0x6088d94C5a40CEcd3ae2D4e0710cA687b91c61d0;
    address tokenApprove = 0x40aA958dd87FC8305b97f2BA922CDdCa374bcD7f;
    address USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address refer1 = 0x000000000000000000000000000000000000dEaD;
    address refer2 = 0x000000000000000000000000000000000000bEEF;
    uint256 rate1 = 0.0001 * 10 ** 9;
    uint256 rate2 = (2 * rate1) / 10;
    bytes usdt_usdc_unxV2 =
        hex"9871efa4000000000036d00c69732701dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000000000000000000000000000000000000bebc200000000000000000000000000000000000000000000000000000000000bd3c9cc00000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000001b0000000000000003b6d03403041cbd36888becc7bbcbc0045e3b1f144466f5f";
    bytes usdt_usdc_unxV3 =
        hex"0d5f0e3b000000000036d00ded6b238154b6032105a6dbdcdb21ad4a2707a8909af153d7000000000000000000000000000000000000000000000000000000000bebc2000000000000000000000000000000000000000000000000000000000005f64ede000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000018000000000000000000000003416cf6c708da44db2624d63ea0aaef7113527c6";
    bytes usdt_usdc_smartswap =
        hex"b80c2f090000000000000000000000000000000000000000000000000036d00ee5fc2701000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000000000000000000000000000000000000bebc2000000000000000000000000000000000000000000000000000000000005f65f440000000000000000000000000000000000000000000000000000000068514c870000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000004200000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000bebc200000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000160000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000000000000000000000000000000000000000000100000000000000000000000016623c35ef61d92aaaf98f25bd64ea962fbd6a12000000000000000000000000000000000000000000000000000000000000000100000000000000000000000016623c35ef61d92aaaf98f25bd64ea962fbd6a1200000000000000000000000000000000000000000000000000000000000000010000000000000000000027100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000080000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000";

    function setUp() public {
        vm.createSelectFork(
            // "https://eth-mainnet.nodereal.io/v1/1659dfb40aa24bbb8153a677b98064d7"
            "https://eth.llamarpc.com",
            22724106
        );
        vm.etch(dexRouter, address(new DexRouter()).code);
        vm.warp(100);
        deal(USDT, user, 10000 * 10 ** 6);
        deal(USDT, dexRouter, 0);
        vm.startPrank(user);
        SafeERC20.safeApprove(IERC20(USDT), tokenApprove, 0);
        SafeERC20.safeApprove(IERC20(USDT), tokenApprove, type(uint256).max);
        vm.label(user, "user");

        vm.stopPrank();
    }

    function _getCommissionInfo(
        bool _hasNextRefer,
        bool _isToB,
        bool _isFrom,
        address _token
    ) internal view returns (bytes memory data) {
        uint256 flag = _isFrom
            ? (
                _hasNextRefer
                    ? FROM_TOKEN_COMMISSION_DUAL
                    : FROM_TOKEN_COMMISSION
            )
            : (_hasNextRefer ? TO_TOKEN_COMMISSION_DUAL : TO_TOKEN_COMMISSION);

        bytes32 first = bytes32(
            flag + uint256(rate1 << 160) + uint256(uint160(refer1))
        );
        bytes32 middle = bytes32(
            abi.encodePacked(uint8(_isToB ? 0x80 : 0), uint88(0), _token)
        );
        bytes32 last = bytes32(
            flag + uint256(rate2 << 160) + uint256(uint160(refer2))
        );
        uint256 status;
        assembly {
            function _getStatus(token, isToB, hasNextRefer) -> d {
                let a := mul(eq(token, _ETH), 256)
                let b := mul(isToB, 16)
                let c := hasNextRefer
                d := add(a, add(b, c))
            }
            status := _getStatus(_token, _isToB, _hasNextRefer)
        }
        console2.log("status", status);
        return
            _hasNextRefer
                ? abi.encode(last, middle, first)
                : abi.encode(middle, first);
    }

    function test_swap_usdt_usdc_smartswap_single() public {
        vm.startPrank(user);
        bytes memory data = bytes.concat(
            usdt_usdc_smartswap,
            _getCommissionInfo(true, true, true, USDT)
            // _getCommissionInfo(true, true, false, USDC)
        );
        (bool s, bytes memory res) = dexRouter.call(data);
        require(s, string(res));
    }
}
