// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "forge-std/console2.sol";
import "@dex/DexRouter.sol";

contract Commission2BScript is Test {
    address internal constant _ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint256 internal constant _ADDRESS_MASK =
        0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff;
    uint256 constant FROM_TOKEN_COMMISSION =
        0x3ca20afc2aaa0000000000000000000000000000000000000000000000000000;
    uint256 constant TO_TOKEN_COMMISSION =
        0x3ca20afc2bbb0000000000000000000000000000000000000000000000000000;
    uint256 constant FROM_TOKEN_COMMISSION_DUAL =
        0x22220afc2aaa0000000000000000000000000000000000000000000000000000;
    uint256 constant TO_TOKEN_COMMISSION_DUAL =
        0x22220afc2bbb0000000000000000000000000000000000000000000000000000;
    uint256 constant _TO_B_COMMISSION_MASK =
        0x8000000000000000000000000000000000000000000000000000000000000000;

    address dexRouter = 0xF4858d71e5d7D27e3F7270390Cd57545DcA35aa9;
    address tokenApprove = 0x7d6a100553e1bb2F98f48986381C9e6FD9945Ac6;

    address USDT = 0x55d398326f99059fF775485246999027B3197955;
    address USDC = 0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d;
    address refer1 = 0x000000000000000000000000000000000000dEaD;
    address refer2 = 0x000000000000000000000000000000000000bEEF;
    uint256 rate1 = 0.0001 * 10 ** 9;
    uint256 rate2 = (2 * rate1) / 10;
    bytes usdc_usdt_smartswap =
        hex"b80c2f090000000000000000000000000000000000000000000000000036d524fb113ac10000000000000000000000008ac76a51cc950d9822d68b83fe1ad97b32cd580d00000000000000000000000055d398326f99059ff775485246999027b319795500000000000000000000000000000000000000000000000000005af3107a400000000000000000000000000000000000000000000000000000002d75995363c400000000000000000000000000000000000000000000000000000000685299dc000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000001600000000000000000000000000000000000000000000000000000000000000440000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000005af3107a4000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000001600000000000000000000000008ac76a51cc950d9822d68b83fe1ad97b32cd580d00000000000000000000000000000000000000000000000000000000000000010000000000000000000000007a7ad9aa93cd0a2d0255326e5fb145cec14997ff00000000000000000000000000000000000000000000000000000000000000010000000000000000000000007a7ad9aa93cd0a2d0255326e5fb145cec14997ff00000000000000000000000000000000000000000000000000000000000000018000000000000000000027102c3c320d49019d4f9a92352e947c7e5acfe47d680000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000400000000000000000000000008ac76a51cc950d9822d68b83fe1ad97b32cd580d00000000000000000000000055d398326f99059ff775485246999027b31979550000000000000000000000000000000000000000000000000000000000000000";
    address deployer = vm.rememberKey(vm.envUint("PRIVATE_KEY_DEPLOYER"));

    function run() public {
        vm.createSelectFork("https://bsc.meowrpc.com");
        vm.startBroadcast(deployer);
        test_swap_usdc_usdt_smartswap();
    }

    function _getCommissionInfo(
        bool _hasNextRefer,
        bool _isToB,
        bool _isFrom,
        address _token
    ) internal view returns (bytes memory data) {
        uint256 flag = _isFrom
            ? (
                _hasNextRefer
                    ? FROM_TOKEN_COMMISSION_DUAL
                    : FROM_TOKEN_COMMISSION
            )
            : (_hasNextRefer ? TO_TOKEN_COMMISSION_DUAL : TO_TOKEN_COMMISSION);

        bytes32 first = bytes32(
            flag + uint256(rate1 << 160) + uint256(uint160(refer1))
        );
        bytes32 middle = bytes32(
            abi.encodePacked(uint8(_isToB ? 0x80 : 0), uint88(0), _token)
        );
        bytes32 last = bytes32(
            flag + uint256(rate2 << 160) + uint256(uint160(refer2))
        );
        uint256 status;
        assembly {
            function _getStatus(token, isToB, hasNextRefer) -> d {
                let a := mul(eq(token, _ETH), 256)
                let b := mul(isToB, 16)
                let c := hasNextRefer
                d := add(a, add(b, c))
            }
            status := _getStatus(_token, _isToB, _hasNextRefer)
        }
        console2.log("status", status);
        return
            _hasNextRefer
                ? abi.encode(last, middle, first)
                : abi.encode(middle, first);
    }

    function test_swap_usdc_usdt_smartswap() internal {
        // IERC20(USDC).approve(tokenApprove, type(uint).max);
        bytes memory data = bytes.concat(
            usdc_usdt_smartswap,
            _getCommissionInfo(true, false, false, USDT)
        );
        (bool s, bytes memory res) = dexRouter.call(data);
        require(s, string(res));
    }
}
