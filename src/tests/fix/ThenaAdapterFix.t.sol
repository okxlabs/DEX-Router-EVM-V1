// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import {ThenaAdapterFix} from "@dex/adapter/ThenaAdapterFix.sol";
import {ThenaAdapter} from "@dex/adapter/ThenaAdapter.sol";
import {IERC20} from "@dex/interfaces/IERC20.sol";
import {IPair} from "@dex/interfaces/ISolidly.sol";

contract ThenaAdapterFixTest is Test {
    ThenaAdapter public adapter;
    ThenaAdapterFix public adapterFix;
    address pair = 0xc7419EBbc4b259C50D7Eeaba49940688A5d52Afa;
    address token0 = 0x90C97F71E18723b0Cf0dfa30ee176Ab653E89F40;
    address token1 = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;

    uint256 constant PROBLEMATIC_AMOUNT = 1_525_318_352_269_930;
    uint256 constant EXPECTED_OUTPUT = 1_010_059_645_868_784_414;

    uint256 constant FEE = 1; // 1/10000 for stable pool

    uint256 constant LARGE_AMOUNT = 1_000_000 * 1e18;
    uint256 constant SMALL_AMOUNT = 1000 * 1e18;

    address recipient = makeAddr("recipient");

    function setUp() public {
        vm.createSelectFork("https://bsc.therpc.io");
        adapter = new ThenaAdapter();
        adapterFix = new ThenaAdapterFix();
    }

    // Test will fail if ThenaAdapter contract won't subtract 1000 from the amountOut
    function test_ThenaAdapter_sellQuote() public {
        uint256 sellAmount = PROBLEMATIC_AMOUNT;
        deal(token1, address(this), sellAmount);

        uint256 originalAmountOut = IPair(pair).getAmountOut(sellAmount, token1);
        console2.log("Original token0 amount out:", originalAmountOut);

        IERC20(token1).transfer(pair, sellAmount);
        adapter.sellQuote(recipient, pair, ""); // Will revert with 'K' if ThenaAdapter contract won't subtract 1000 from the amountOut

        console2.log("Actual token0 received:", IERC20(token0).balanceOf(recipient));
    }

    function test_ThenaAdapterFix_sellQuote() public {
        uint256 sellAmount = PROBLEMATIC_AMOUNT;
        deal(token1, address(this), sellAmount);

        uint256 originalAmountOut = IPair(pair).getAmountOut(sellAmount, token1);
        console2.log("Original token0 amount out:", originalAmountOut);

        IERC20(token1).transfer(pair, sellAmount);
        bool isStable = IPair(pair).isStable();
        adapterFix.sellQuote(recipient, pair, abi.encode(FEE, isStable));

        console2.log("Actual token0 received:", IERC20(token0).balanceOf(recipient));
    }

    // Original amount out satisfy the k check, no adjustment needed
    function test_ThenaAdapterFix_sellBase() public {
        uint256 sellAmount = EXPECTED_OUTPUT;
        deal(token0, address(this), sellAmount);

        uint256 originalAmountOut = IPair(pair).getAmountOut(sellAmount, token0);
        console2.log("Original token1 amount out:", originalAmountOut);

        IERC20(token0).transfer(pair, sellAmount);
        bool isStable = IPair(pair).isStable();
        adapterFix.sellBase(recipient, pair, abi.encode(FEE, isStable));

        console2.log("Actual token1 received:", IERC20(token1).balanceOf(recipient));
    }

    function test_op_thena_swap() public {
        // https://app.blocksec.com/explorer/tx/optimism/0x8ea763be2686335aff41bf1a06f43fade331aef5aac364679968d611e0e35e24?event=simulation&type=0&timestamp=1753945734890&line=238
        vm.createSelectFork("https://mainnet.optimism.io", 138832750);
        address adaptor = 0xd30D8CA2E7715eE6804a287eB86FAfC0839b1380;
        vm.etch(adaptor, address(new ThenaAdapterFix()).code);
        bytes memory data =
            hex"b80c2f0900000000000000000000000000000000000000000000000000378950b62633ca000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000000b2c639c533813f4aa9d7837caf62653d097ff8500000000000000000000000000000000000000000000000000005af3107a40000000000000000000000000000000000000000000000000000000000000043b0e00000000000000000000000000000000000000000000000000000000a41b8835000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000001600000000000000000000000000000000000000000000000000000000000000860000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000005af3107a4000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000002c000000000000000000000000000000000000000000000000000000000000004a000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000016000000000000000000000000042000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000001000000000000000000000000411d2c093e4c2e69bf0d8e94be1bf13dadd879c60000000000000000000000000000000000000000000000000000000000000001000000000000000000000000411d2c093e4c2e69bf0d8e94be1bf13dadd879c60000000000000000000000000000000000000000000000000000000000000001000000000000000000002710fc1f3296458f9b2a27a0b91dd7681c4020e09d050000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000400000000000000000000000004200000000000000000000000000000000000006000000000000000000000000420000000000000000000000000000000000004200000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000001600000000000000000000000004200000000000000000000000000000000000042000000000000000000000000000000000000000000000000000000000000000100000000000000000000000009a191de731c61a9fcc1e9c6759a7355b61aa2a3000000000000000000000000000000000000000000000000000000000000000100000000000000000000000009a191de731c61a9fcc1e9c6759a7355b61aa2a300000000000000000000000000000000000000000000000000000000000000010000000000000000000027100e736045cf438d813848ffd7c9f1443dac3e2a3d000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000020000000000000000000000000420000000000000000000000000000000000004200000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000001600000000000000000000000008c6f28f2f1a3c87f0f938b96d27520d9751ec8d90000000000000000000000000000000000000000000000000000000000000001000000000000000000000000d30d8ca2e7715ee6804a287eb86fafc0839b13800000000000000000000000000000000000000000000000000000000000000001000000000000000000000000bc26519f936a90e78fe2c9aa2a03cc208f0412340000000000000000000000000000000000000000000000000000000000000001800000000000000000002710bc26519f936a90e78fe2c9aa2a03cc208f041234000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000";
        address DexRouter = 0x9b9efa5Efa731EA9Bbb0369E91fA17Abf249CFD4;
        address user = 0x618C792F56E9b4309e5894331BDb4F6800082390;
        uint256 value = 0.0001 ether;
        vm.prank(user);
        (bool s, bytes memory res) = DexRouter.call{value: value}(data);
        require(s, "Failed to swap");
    }
}
